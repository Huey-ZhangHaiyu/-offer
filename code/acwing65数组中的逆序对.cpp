/*
在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
输入一个数组，求出这个数组中的逆序对的总数。
输入：[1,2,3,4,5,6,0]
输出：6
*/
//先自己写一个试试
//双指针暴力做法O(n^2)
class Solution {
public:
    int inversePairs(vector<int>& nums) {
        int i,j;
        int count=0;
        int n=nums.size();
        for(i=0;i<n;i++){
            for(j=i+1;j<n;j++){
                if(nums[i]>nums[j]) count ++;
            }
        }
        return count;
    }
};

//大佬，经典题目
/*
用归并排序顺便解决这个问题
归并排序拆成左右两个区间，那么存在的逆序对就是左边的逆序+右逆序+跨越区间的逆序
首先想到的暴力一定不是面试官想要的，暴力的复杂度为n平方
那么比暴力更快一点的复杂度为nlogn，怎么才会有logn出现呢
一半一半就会有logn出现
怎么样把一半一半用到这道题上呢
将数组[1,2,3,4,5,6,0]对半切，变成arr1=[1,2,3,4]和arr2=[5,6,0]
将arr1里的1和arr2的5做比较，发现1<5，要是arr2里的0是7或者8就好了，这样1就比arr2里的所有数字都小了呢，就不存在逆序对了
那么假设arr2排过序了是[0,5,6],刚好arr1目前也是排过序的
1、arr1里的1是大于arr2里的0的，那么arr1里1且其之后的所有数字都比0大，则对于0来说，有4个数字比它大，所以结果变量+4,0被arr1里的所有数字都比较过了（也不是一个个遍历比较，而是用了有序的性质），0就可以被丢弃了（实际上是放到归并排序的临时数组里了）
2、此时1是小于5的，那么可以断定1比arr2里的所有数字都小，也可以把1和之前的0一样处理掉
3、现在arr1=[2,3,4] arr2=[5,6],2小于5，所以2比arr2里的都要小，丢弃，一直循环下去，4也被丢掉，逆序对完成

所以解法就是归并排序，只加了一行res+=mid-i+1;
递归里面运行完两个mergeSort后，start~mid 和 mid+1~end都是有序的，且两个内部的逆序对都已经算过了，只需要算当前状态的逆序对就行了，不会重复的
*/
