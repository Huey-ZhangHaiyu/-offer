/*
给定一个数字，我们按照如下规则把它翻译为字符串：
0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。
一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。
请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。

样例
输入："12258"
输出：5
*/

/*dp问题
动态规划的核心：找状态，描述状态，状态转移
如果用f[i]来描述前i位最多的翻译状态
那么f[i]就可以描述为f[i-1](第i位单独翻译)+f[i-2](第i和i-1位一起翻译)
转移到f[i-1]一定可以，而转移f[i-2]的条件则是i-1和i一起组成的数字>=10&&<=25
边界情况则是f[0]=1种
*/
class Solution {
public:
    int getTranslationCount(string s) {
        int n=s.size();
        vector<int> f(n+1);//从长度为1开始判断不会向下越界，加上0的情况，一共n+1
        f[0]=1;
        for(int i=1;i<n+1;i++){
            f[i]=f[i-1];
            int t=(s[i-2]-'0')*10+s[i-1]-'0';//i-1和i-2组成的数字，字符串转数字偏移0
            if(t>=10&&t<=25) f[i]+=f[i-2];//满足条件可以转移
        }
        return f[n];
    }
};
